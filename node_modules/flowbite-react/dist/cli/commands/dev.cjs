'use strict';

var fs = require('fs/promises');
var path = require('path');
var chokidar = require('chokidar');
var isEqual = require('../../helpers/is-equal.cjs');
var consts = require('../consts.cjs');
var buildClassList = require('../utils/build-class-list.cjs');
var createInitLogger = require('../utils/create-init-logger.cjs');
var extractComponentImports = require('../utils/extract-component-imports.cjs');
var findFiles = require('../utils/find-files.cjs');
var getClassList = require('../utils/get-class-list.cjs');
var getConfig = require('../utils/get-config.cjs');
var setupGitignore = require('./setup-gitignore.cjs');
var setupInit = require('./setup-init.cjs');
var setupOutputDirectory = require('./setup-output-directory.cjs');

async function dev() {
  await setupOutputDirectory.setupOutputDirectory();
  let config = await getConfig.getConfig();
  await setupInit.setupInit(config);
  const initLogger = createInitLogger.createInitLogger(config);
  if (config.components.length) {
    console.warn(consts.automaticClassGenerationMessage);
  }
  const importedComponentsMap = {};
  let classList = await getClassList.getClassList();
  const files = await findFiles.findFiles({
    patterns: consts.allowedExtensions.map((ext) => `**/*${ext}`),
    excludeDirs: consts.excludeDirs
  });
  for (const file of files) {
    const content = await fs.readFile(file, "utf-8");
    const componentImports = extractComponentImports.extractComponentImports(content);
    initLogger.check(file, content);
    if (componentImports.length) {
      importedComponentsMap[file] = componentImports;
    }
  }
  initLogger.log();
  const newImportedComponents = [...new Set(Object.values(importedComponentsMap).flat())];
  const newClassList = buildClassList.buildClassList({
    components: config.components.length ? config.components : newImportedComponents,
    dark: config.dark,
    prefix: config.prefix,
    version: config.version
  });
  if (!isEqual.isEqual(classList, newClassList)) {
    classList = newClassList;
    console.log(`Generating ${consts.classListFilePath} file...`);
    await fs.writeFile(consts.classListFilePath, JSON.stringify(classList, null, 2));
  }
  async function handleChange(path, eventName) {
    if ([consts.configFilePath, consts.initFilePath, consts.initJsxFilePath].includes(path)) {
      config = await getConfig.getConfig();
      await setupInit.setupInit(config);
      initLogger.config = config;
    }
    if (path === consts.gitIgnoreFilePath) {
      await setupGitignore.setupGitIgnore();
    }
    if (eventName === "change") {
      const content = await fs.readFile(path, "utf-8");
      const componentImports = extractComponentImports.extractComponentImports(content);
      initLogger.check(path, content);
      if (componentImports.length) {
        importedComponentsMap[path] = componentImports;
      } else {
        delete importedComponentsMap[path];
      }
    }
    if (eventName === "unlink") {
      delete importedComponentsMap[path];
      initLogger.checkedMap.delete(path);
    }
    initLogger.log();
    const newImportedComponents2 = [...new Set(Object.values(importedComponentsMap).flat())];
    const newClassList2 = buildClassList.buildClassList({
      components: config.components.length ? config.components : newImportedComponents2,
      dark: config.dark,
      prefix: config.prefix,
      version: config.version
    });
    if (!isEqual.isEqual(classList, newClassList2)) {
      classList = newClassList2;
      console.log(`Generating ${consts.classListFilePath} file...`);
      await fs.writeFile(consts.classListFilePath, JSON.stringify(classList, null, 2));
    }
  }
  const watcher = chokidar.watch(".", {
    ignored: (path$1, stats) => {
      if (stats?.isDirectory()) {
        return consts.excludeDirs.includes(path.basename(path$1));
      }
      if (stats?.isFile()) {
        return !consts.allowedExtensions.concat(consts.configFilePath, consts.gitIgnoreFilePath, consts.initFilePath, consts.initJsxFilePath).some((ext) => path$1.endsWith(ext));
      }
      return false;
    },
    ignoreInitial: true
  });
  watcher.on("add", (path) => handleChange(path, "change"));
  watcher.on("change", (path) => handleChange(path, "change"));
  watcher.on("unlink", (path) => handleChange(path, "unlink"));
}

exports.dev = dev;
//# sourceMappingURL=dev.cjs.map
